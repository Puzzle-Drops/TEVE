<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TEVE - Twilight's Forever</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="gameContainer">
        <!-- Main Menu -->
        <div id="mainMenu">
            <h1 class="gameTitle">TEVE</h1>
            <div class="menuButtons">
                <button class="menuButton" onclick="game.showHeroesScreen()">Heroes</button>
                <button class="menuButton" onclick="game.showDungeonsScreen()">Dungeons</button>
                <button class="menuButton" onclick="game.showStashScreen()">Stash</button>
            </div>
        </div>

        <!-- Heroes Screen -->
        <div id="heroesScreen">
            <button class="backButton" onclick="game.showMainMenu()">‚Üê Back</button>
            <div class="goldDisplay">
                <span class="goldIcon">üí∞</span>
                <span class="goldAmount">0</span>
            </div>
            <div class="heroPanel">
                <div class="heroPortrait"></div>
                <div class="heroStats">
                    <div class="heroTabs">
                        <button class="tabButton active" onclick="game.showTab('info')">Info</button>
                        <button class="tabButton" onclick="game.showTab('skills')">Skills</button>
                        <button class="tabButton" onclick="game.showTab('promote')">Promote</button>
                        <button class="tabButton" onclick="game.showTab('gear')">Gear</button>
                        <button class="tabButton" onclick="game.showTab('log')">Log</button>
                    </div>
                    <div class="tabContent"></div>
                </div>
            </div>
            <div class="heroList"></div>
        </div>

        <!-- Dungeons Screen -->
        <div id="dungeonsScreen">
            <button class="backButton" onclick="game.showMainMenu()">‚Üê Back</button>
            <div class="worldMap"></div>
            <div class="dungeonListPanel"></div>
        </div>

        <!-- Stash Screen -->
        <div id="stashScreen">
            <button class="backButton" onclick="game.showMainMenu()">‚Üê Back</button>
            <h2 class="stashTitle">Stash</h2>
            <div class="stashGrid"></div>
        </div>

        <!-- Battle Scene -->
        <div id="battleScene">
            <div class="battleField"></div>
            <button class="exitBattleButton" onclick="game.exitBattle()">Exit Battle</button>
            
            <!-- Unit slots will be created dynamically -->
            
            <div class="battleUI">
                <div class="battleLog" id="battleLog"></div>
                <div class="abilityPanel" id="abilityPanel"></div>
            </div>
            
            <div class="autoToggleContainer">
                <label>
                    <input type="checkbox" id="autoToggle" onchange="game.toggleAutoMode(this.checked)">
                    Auto Battle
                </label>
            </div>
        </div>

        <!-- Party Select Screen -->
        <div id="partySelectScreen">
            <button class="backButton" onclick="game.cancelPartySelect()">‚Üê Back</button>
            <div class="partySelectContainer">
                <div class="partySelectHeader">
                    <h2 class="dungeonTitle"></h2>
                    <div class="waveNavigation">
                        <button class="waveArrow" onclick="game.previousWave()">‚óÑ</button>
                        <span class="waveText">Wave: 1/1</span>
                        <button class="waveArrow" onclick="game.nextWave()">‚ñ∫</button>
                    </div>
                </div>
                <div class="battlePreview">
                    <div>
                        <div class="partyLabel">
                            <span class="partyLabelText">Your Party</span>
                        </div>
                        <div class="partyFormation">
                            <div class="partySlot" data-slot="0"><div class="slotPlaceholder">+</div></div>
                            <div class="partySlot" data-slot="1"><div class="slotPlaceholder">+</div></div>
                            <div class="partySlot" data-slot="2"><div class="slotPlaceholder">+</div></div>
                            <div class="partySlot" data-slot="3"><div class="slotPlaceholder">+</div></div>
                            <div class="partySlot" data-slot="4"><div class="slotPlaceholder">+</div></div>
                        </div>
                    </div>
                    <div class="vsText">VS</div>
                    <div>
                        <div class="enemyFormation">
                            <div class="enemySlot" data-slot="0"></div>
                            <div class="enemySlot" data-slot="1"></div>
                            <div class="enemySlot" data-slot="2"></div>
                            <div class="enemySlot" data-slot="3"></div>
                            <div class="enemySlot" data-slot="4"></div>
                        </div>
                    </div>
                </div>
                <div class="heroSelectArea">
                    <div class="heroSelectList"></div>
                    <div class="actionButtons">
                        <button class="startBattleBtn" onclick="game.startBattleWithParty()">Start Battle</button>
                        <button class="cancelBtn" onclick="game.cancelPartySelect()">Cancel</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Confirmation Modal -->
        <div id="confirmModal" class="confirmModal">
            <div class="confirmContent">
                <p class="confirmText"></p>
                <p class="confirmCost">üí∞ <span></span></p>
                <div class="confirmButtons">
                    <button class="confirmBtn confirmYes">Yes</button>
                    <button class="confirmBtn confirmNo">No</button>
                </div>
            </div>
        </div>

        <!-- Battle Results Popup -->
        <div id="battleResultsPopup" class="battleResultsPopup">
            <div class="resultsHeader">
                <h2 class="resultsTitle">Victory!</h2>
                <div class="dungeonInfo"></div>
            </div>
            <div class="rewardsSection">
                <div class="rewardLine">
                    <span class="rewardLabel">Time:</span>
                    <span class="rewardValue" id="battleTime">00:00</span>
                </div>
                <div class="rewardLine">
                    <span class="rewardLabel">Gold:</span>
                    <span class="rewardValue" id="goldChange">+0</span>
                </div>
            </div>
            <div class="heroResultsSection">
                <h3 class="heroResultsTitle">Heroes</h3>
                <div class="heroResultsGrid"></div>
            </div>
            <button class="closeResultsBtn" onclick="game.closeBattleResults()">Continue</button>
        </div>

        <!-- Hero Info Popup -->
        <div id="heroInfoPopup" class="heroInfoPopup">
            <div class="heroInfoHeader">
                <h3 class="heroInfoTitle">Hero Info</h3>
                <button class="closeInfoBtn" onclick="game.closeHeroInfo()">√ó</button>
            </div>
            <div class="heroInfoContent">
                <div class="heroInfoStats"></div>
                <div class="heroInfoGear"></div>
            </div>
        </div>

        <!-- Ability Tooltip -->
        <div id="abilityTooltip" style="display: none;"></div>
    </div>

    <script>
        // Game data
        let classData = null;
        let enemyData = null;
        let dungeonData = null;
        let spellManager = null;
        let game = null;

        // Load game data
        async function loadGameData() {
            try {
                // Load units data
                const unitsResponse = await fetch('units.json');
                const unitsData = await unitsResponse.json();
                classData = unitsData;
                enemyData = unitsData.enemies;

                // Load dungeon data
                const dungeonResponse = await fetch('dungeons.json');
                dungeonData = await dungeonResponse.json();

                // Load spell data
                spellManager = new SpellManager();
                await spellManager.loadSpells();

                // Initialize game
                game = new Game();
                game.init();
            } catch (error) {
                console.error('Failed to load game data:', error);
            }
        }

        // Hero class with gender system
        class Hero {
            constructor(name, classKey, level = 1) {
                this.name = name;
                this.classKey = classKey;
                this.level = level;
                this.exp = 0;
                this.currentClass = classData.classes[classKey];
                this.classTier = this.currentClass.tier;
                this.awakened = false;
                this.gear = {
                    head: null,
                    chest: null,
                    legs: null,
                    weapon: null,
                    offhand: null,
                    trinket: null
                };
                this.pendingExp = 0;
                
                // Assign random gender on creation
                this.gender = Math.random() < 0.5 ? 'male' : 'female';
            }

            get totalStats() {
                const baseStats = {
                    str: Math.floor(this.level * this.currentClass.modifiers.str),
                    agi: Math.floor(this.level * this.currentClass.modifiers.agi),
                    int: Math.floor(this.level * this.currentClass.modifiers.int)
                };

                // Add gear stats
                const gearStats = this.gearStats;
                baseStats.str += gearStats.str || 0;
                baseStats.agi += gearStats.agi || 0;
                baseStats.int += gearStats.int || 0;

                return baseStats;
            }

            get gearStats() {
                const stats = { str: 0, agi: 0, int: 0, armor: 0, resist: 0 };
                
                Object.values(this.gear).forEach(item => {
                    if (item) {
                        stats.str += item.stats.str || 0;
                        stats.agi += item.stats.agi || 0;
                        stats.int += item.stats.int || 0;
                        stats.armor += item.stats.armor || 0;
                        stats.resist += item.stats.resist || 0;
                    }
                });

                return stats;
            }

            get hp() {
                return this.totalStats.str * 25;
            }

            get abilities() {
                const abilities = [];
                const spells = this.currentClass.spells || [];
                
                // Add regular spells (1-3)
                spells.forEach((spellId, index) => {
                    const spell = spellManager.getSpell(spellId);
                    if (spell) {
                        abilities.push({
                            id: spellId,
                            name: spell.name,
                            level: Math.min(index + 1, this.classTier + 1),
                            cooldown: spell.cooldown || 0,
                            passive: spell.target === 'passive'
                        });
                    }
                });
                
                // Add gender-based passive ability for tier 4
                if (this.classTier === 4) {
                    const genderPassive = this.currentClass[`${this.gender}Passive`];
                    if (genderPassive) {
                        const spell = spellManager.getSpell(genderPassive);
                        if (spell) {
                            abilities.push({
                                id: genderPassive,
                                name: spell.name,
                                level: this.awakened ? 5 : 4,
                                cooldown: 0,
                                passive: true,
                                aura: true
                            });
                        }
                    }
                }
                
                return abilities;
            }

            get expToNext() {
                return Math.floor(100 * Math.pow(1.5, this.level - 1));
            }

            addExp(amount) {
                this.exp += amount;
                let leveledUp = false;

                while (this.exp >= this.expToNext && this.level < 500) {
                    this.exp -= this.expToNext;
                    this.level++;
                    leveledUp = true;
                }

                if (this.level >= 500) {
                    this.exp = 0;
                }

                return leveledUp;
            }

            promote(newClassKey) {
                this.classKey = newClassKey;
                this.currentClass = classData.classes[newClassKey];
                this.classTier = this.currentClass.tier;
                this.level = 1;
                this.exp = 0;
            }

            // Update sprite paths to include gender
            get portraitPath() {
                const className = this.currentClass.name.toLowerCase().replace(' ', '_');
                return `https://puzzle-drops.github.io/TEVE/img/sprites/${className}_${this.gender}_portrait.png`;
            }
            
            get battleSpritePath() {
                const className = this.currentClass.name.toLowerCase().replace(' ', '_');
                return `https://puzzle-drops.github.io/TEVE/img/sprites/${className}_${this.gender}_battle.png`;
            }

            // Add method for gender-aware display name
            getDisplayClassName() {
                // Check if this class has gender-specific names
                const genderVariants = {
                    'Priest': { male: 'Priest', female: 'Priestess' },
                    'Prophet': { male: 'Prophet', female: 'Prophetess' },
                    'Hierophant': { male: 'Hierophant', female: 'High Priestess' },
                    'Wizard': { male: 'Wizard', female: 'Witch' },
                    'White Wizard': { male: 'White Wizard', female: 'White Witch' },
                    'Arch Sage': { male: 'Arch Sage', female: 'Arch Sorceress' }
                };
                
                if (genderVariants[this.currentClass.name]) {
                    return genderVariants[this.currentClass.name][this.gender];
                }
                
                return this.currentClass.name;
            }
        }

        // Game Core Class
        class Game {
            constructor() {
                this.heroes = [];
                this.selectedHero = null;
                this.selectedParty = [];
                this.currentTab = 'info';
                this.gold = 10000;
                this.currentBattle = null;
                this.currentScreen = 'mainMenu';
                this.currentDungeon = null;
                this.currentPreviewWave = 0;
                this.dungeonWaves = [];
                this.selectedTier = null;
                this.dungeonTiers = {};
                this.pendingBattleResults = null;
            }

            init() {
                // Create starting heroes
                this.heroes = [
                    new Hero('Aelar', 'villager'),
                    new Hero('Brin', 'villager'),
                    new Hero('Cara', 'villager')
                ];

                // Load dungeon tiers
                if (dungeonData && dungeonData.tiers) {
                    Object.keys(dungeonData.tiers).forEach(tierName => {
                        const tierData = dungeonData.tiers[tierName];
                        this.dungeonTiers[tierName] = {
                            ...tierData,
                            dungeons: []
                        };
                    });
                    
                    Object.keys(dungeonData.dungeons).forEach(dungeonId => {
                        const dungeon = dungeonData.dungeons[dungeonId];
                        if (this.dungeonTiers[dungeon.tier]) {
                            this.dungeonTiers[dungeon.tier].dungeons.push({
                                id: dungeonId,
                                name: dungeon.name,
                                boss: dungeon.boss,
                                subtitle: dungeon.subtitle,
                                level: dungeon.level
                            });
                        }
                    });
                }
            }

            showMainMenu() {
                this.hideAllScreens();
                this.currentScreen = 'mainMenu';
                document.getElementById('mainMenu').style.display = 'flex';
            }

            showHeroesScreen() {
                this.hideAllScreens();
                this.currentScreen = 'heroesScreen';
                document.getElementById('heroesScreen').style.display = 'block';
                this.updateHeroList();
                this.updateGoldDisplay();
                
                if (this.heroes.length > 0 && this.selectedHero === null) {
                    this.selectedHero = 0;
                }
                
                if (this.selectedHero !== null) {
                    this.selectHero(this.selectedHero);
                }
            }

            showDungeonsScreen() {
                this.hideAllScreens();
                this.currentScreen = 'dungeonsScreen';
                document.getElementById('dungeonsScreen').style.display = 'block';
                this.renderWorldMap();
            }

            showStashScreen() {
                this.hideAllScreens();
                this.currentScreen = 'stashScreen';
                document.getElementById('stashScreen').style.display = 'block';
                this.renderStashGrid();
            }

            hideAllScreens() {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('heroesScreen').style.display = 'none';
                document.getElementById('dungeonsScreen').style.display = 'none';
                document.getElementById('stashScreen').style.display = 'none';
                document.getElementById('battleScene').style.display = 'none';
                document.getElementById('partySelectScreen').style.display = 'none';
            }

            updateGoldDisplay() {
                const goldAmount = document.querySelector('.goldAmount');
                if (goldAmount) {
                    goldAmount.textContent = this.gold.toLocaleString();
                }
            }

            updateHeroList() {
                const heroList = document.querySelector('.heroList');
                heroList.innerHTML = '';

                // Sort heroes by tier and level
                const sortedHeroes = [...this.heroes].sort((a, b) => {
                    if (a.classTier !== b.classTier) return b.classTier - a.classTier;
                    return b.level - a.level;
                });

                sortedHeroes.forEach((hero, index) => {
                    const heroIndex = this.heroes.indexOf(hero);
                    const heroThumb = this.createHeroThumb(hero, heroIndex);
                    heroList.appendChild(heroThumb);
                });
            }

            createHeroThumb(hero, index) {
                const thumb = document.createElement('div');
                thumb.className = 'heroThumb';
                if (index === this.selectedHero) {
                    thumb.classList.add('selected');
                }

                const portrait = document.createElement('img');
                portrait.src = hero.portraitPath;
                portrait.alt = hero.name;
                portrait.onerror = function() { this.style.display = 'none'; };

                const info = document.createElement('div');
                info.className = 'heroThumbInfo';
                info.innerHTML = `
                    <div class="heroThumbName">${hero.name}</div>
                    <div class="heroThumbClass">${hero.getDisplayClassName()}</div>
                    <div class="heroThumbLevel">Lv ${hero.level}</div>
                `;

                thumb.appendChild(portrait);
                thumb.appendChild(info);
                thumb.onclick = () => this.selectHero(index);

                return thumb;
            }

            selectHero(index) {
                this.selectedHero = index;
                this.updateHeroList();
                this.showHeroDetails();
            }

            showHeroDetails() {
                const hero = this.heroes[this.selectedHero];
                if (!hero) return;

                // Update portrait
                const portrait = document.querySelector('.heroPortrait');
                portrait.innerHTML = `<img src="${hero.battleSpritePath}" alt="${hero.name}">`;

                // Show current tab
                this.showTab(this.currentTab);
            }

            showTab(tabName) {
                this.currentTab = tabName;
                
                // Update tab buttons
                document.querySelectorAll('.tabButton').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.textContent.toLowerCase() === tabName) {
                        btn.classList.add('active');
                    }
                });

                // Update content
                const content = document.querySelector('.tabContent');
                const hero = this.heroes[this.selectedHero];

                switch(tabName) {
                    case 'info':
                        this.showInfoTab(hero, content);
                        break;
                    case 'skills':
                        this.showSkillsTab(hero, content);
                        break;
                    case 'promote':
                        this.showPromoteTab(hero, content);
                        break;
                    case 'gear':
                        this.showGearTab(hero, content);
                        break;
                    case 'log':
                        this.showLogTab(hero, content);
                        break;
                }
            }

            showInfoTab(hero, content) {
                const stats = hero.totalStats;
                const gearStats = hero.gearStats;
                
                let stars = '';
                if (hero.classTier > 0) {
                    for (let i = 0; i < hero.classTier; i++) {
                        stars += '‚òÖ';
                    }
                }

                content.innerHTML = `
                    <h2>${hero.getDisplayClassName()}</h2>
                    <h3>${hero.name}</h3>
                    ${stars ? `<div class="heroStars">${stars}</div>` : ''}
                    
                    <div class="heroLevel">Level ${hero.level}</div>
                    <div class="expBar">
                        <div class="expFill" style="width: ${(hero.exp / hero.expToNext) * 100}%"></div>
                        <div class="expText">${hero.exp} / ${hero.expToNext}</div>
                    </div>
                    
                    <div class="statsGrid">
                        <div class="statLine">
                            <span class="statName">HP</span>
                            <span class="statValue">${hero.hp}</span>
                        </div>
                        <div class="statLine">
                            <span class="statName">STR</span>
                            <span class="statValue">${stats.str} ${gearStats.str > 0 ? `<span class="bonus">+${gearStats.str}</span>` : ''}</span>
                        </div>
                        <div class="statLine">
                            <span class="statName">AGI</span>
                            <span class="statValue">${stats.agi} ${gearStats.agi > 0 ? `<span class="bonus">+${gearStats.agi}</span>` : ''}</span>
                        </div>
                        <div class="statLine">
                            <span class="statName">INT</span>
                            <span class="statValue">${stats.int} ${gearStats.int > 0 ? `<span class="bonus">+${gearStats.int}</span>` : ''}</span>
                        </div>
                        <div class="statLine">
                            <span class="statName">Gender</span>
                            <span class="statValue">${hero.gender.charAt(0).toUpperCase() + hero.gender.slice(1)}</span>
                        </div>
                    </div>
                `;
            }

            showSkillsTab(hero, content) {
                const abilities = hero.abilities;
                
                content.innerHTML = `
                    <h3>Abilities</h3>
                    <div class="abilitiesGrid">
                        ${abilities.map((ability, index) => `
                            <div class="abilityBox" onmouseover="game.showAbilityTooltip(event, ${index})">
                                <img src="https://puzzle-drops.github.io/TEVE/img/spells/${ability.id}.png" alt="${ability.name}">
                                <div class="abilityName">${ability.name}</div>
                                ${ability.passive ? '<div class="passiveTag">Passive</div>' : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            showPromoteTab(hero, content) {
                // Promotion logic here
                content.innerHTML = '<p>Promotion options coming soon...</p>';
            }

            showGearTab(hero, content) {
                content.innerHTML = `
                    <h3>Equipment</h3>
                    <div class="gearGrid">
                        <div class="gearSlot">
                            <div class="gearLabel">Head</div>
                            <div class="gearItem">${hero.gear.head ? hero.gear.head.name : 'Empty'}</div>
                        </div>
                        <div class="gearSlot">
                            <div class="gearLabel">Chest</div>
                            <div class="gearItem">${hero.gear.chest ? hero.gear.chest.name : 'Empty'}</div>
                        </div>
                        <div class="gearSlot">
                            <div class="gearLabel">Legs</div>
                            <div class="gearItem">${hero.gear.legs ? hero.gear.legs.name : 'Empty'}</div>
                        </div>
                        <div class="gearSlot">
                            <div class="gearLabel">Weapon</div>
                            <div class="gearItem">${hero.gear.weapon ? hero.gear.weapon.name : 'Empty'}</div>
                        </div>
                        <div class="gearSlot">
                            <div class="gearLabel">Offhand</div>
                            <div class="gearItem">${hero.gear.offhand ? hero.gear.offhand.name : 'Empty'}</div>
                        </div>
                        <div class="gearSlot">
                            <div class="gearLabel">Trinket</div>
                            <div class="gearItem">${hero.gear.trinket ? hero.gear.trinket.name : 'Empty'}</div>
                        </div>
                    </div>
                `;
            }

            showLogTab(hero, content) {
                content.innerHTML = '<p>Activity log coming soon...</p>';
            }

            renderWorldMap() {
                const worldMap = document.querySelector('.worldMap');
                worldMap.innerHTML = '';

                Object.entries(this.dungeonTiers).forEach(([tierName, tierData]) => {
                    const orb = document.createElement('div');
                    orb.className = `mapOrb ${tierData.color}`;
                    orb.style.left = `${tierData.position.x}%`;
                    orb.style.top = `${tierData.position.y}%`;
                    orb.textContent = tierData.tier;
                    orb.onclick = () => this.selectDungeonTier(tierName);
                    
                    worldMap.appendChild(orb);
                });
            }

            selectDungeonTier(tierName) {
                if (this.selectedTier === tierName) {
                    this.closeDungeonPanel();
                    return;
                }

                this.selectedTier = tierName;
                const panel = document.querySelector('.dungeonListPanel');
                panel.innerHTML = `
                    <h2>${tierName}</h2>
                    <div class="dungeonList">
                        ${this.dungeonTiers[tierName].dungeons.map(dungeon => `
                            <div class="dungeonItem" onclick="game.selectDungeon('${dungeon.id}')">
                                <h3>${dungeon.name}</h3>
                                <p>Level ${dungeon.level}</p>
                            </div>
                        `).join('')}
                    </div>
                `;
                panel.classList.add('show');
            }

            closeDungeonPanel() {
                const panel = document.querySelector('.dungeonListPanel');
                panel.classList.remove('show');
                this.selectedTier = null;
            }

            selectDungeon(dungeonId) {
                const dungeonConfig = dungeonData.dungeons[dungeonId];
                if (!dungeonConfig) return;

                this.currentDungeon = {
                    id: dungeonId,
                    name: dungeonConfig.name,
                    level: dungeonConfig.level
                };

                // Create waves
                this.dungeonWaves = dungeonConfig.waves.map(wave => {
                    return wave.enemies.map(enemyConfig => {
                        const enemyClass = enemyData[enemyConfig.id];
                        return {
                            id: enemyConfig.id,
                            name: enemyClass.name,
                            level: enemyConfig.level,
                            modifiers: enemyClass.modifiers,
                            abilities: enemyClass.spells
                        };
                    });
                });

                this.currentPreviewWave = 0;
                this.showPartySelect();
            }

            showPartySelect() {
                this.hideAllScreens();
                this.currentScreen = 'partySelectScreen';
                document.getElementById('partySelectScreen').style.display = 'block';
                
                this.selectedParty = [null, null, null, null, null];
                this.updatePartySelect();
            }

            updatePartySelect() {
                // Update dungeon title
                const title = document.querySelector('.dungeonTitle');
                title.textContent = this.currentDungeon.name;

                // Update wave display
                this.updateWaveDisplay();

                // Update hero list
                this.updateHeroSelectList();

                // Update party slots
                this.updatePartySlots();
            }

            updateWaveDisplay() {
                const waveText = document.querySelector('.waveText');
                waveText.textContent = `Wave: ${this.currentPreviewWave + 1}/${this.dungeonWaves.length}`;

                // Update enemy formation
                const enemyFormation = document.querySelector('.enemyFormation');
                enemyFormation.innerHTML = '';

                const currentWave = this.dungeonWaves[this.currentPreviewWave];
                currentWave.forEach((enemy, index) => {
                    const slot = document.createElement('div');
                    slot.className = 'enemySlot';
                    slot.dataset.slot = index;
                    slot.innerHTML = `
                        <div class="enemyThumb">
                            <div class="enemyName">${enemy.name}</div>
                            <div class="enemyLevel">Lv ${enemy.level}</div>
                        </div>
                    `;
                    enemyFormation.appendChild(slot);
                });
            }

            updateHeroSelectList() {
                const list = document.querySelector('.heroSelectList');
                list.innerHTML = '';

                this.heroes.forEach((hero, index) => {
                    const heroItem = document.createElement('div');
                    heroItem.className = 'selectableHero';
                    if (this.selectedParty.includes(index)) {
                        heroItem.classList.add('inParty');
                    }

                    heroItem.innerHTML = `
                        <img src="${hero.portraitPath}" alt="${hero.name}">
                        <div class="heroSelectInfo">
                            <div>${hero.name}</div>
                            <div>${hero.getDisplayClassName()}</div>
                            <div>Lv ${hero.level}</div>
                        </div>
                    `;

                    heroItem.onclick = () => this.toggleHeroInParty(index);
                    list.appendChild(heroItem);
                });
            }

            updatePartySlots() {
                const slots = document.querySelectorAll('.partySlot');
                slots.forEach((slot, index) => {
                    const heroIndex = this.selectedParty[index];
                    if (heroIndex !== null) {
                        const hero = this.heroes[heroIndex];
                        slot.innerHTML = `
                            <img src="${hero.portraitPath}" alt="${hero.name}">
                            <div class="slotHeroInfo">
                                <div>${hero.name}</div>
                                <div>Lv ${hero.level}</div>
                            </div>
                        `;
                    } else {
                        slot.innerHTML = '<div class="slotPlaceholder">+</div>';
                    }
                });

                // Update start button
                const startBtn = document.querySelector('.startBattleBtn');
                startBtn.disabled = this.selectedParty.every(slot => slot === null);
            }

            toggleHeroInParty(heroIndex) {
                const currentSlot = this.selectedParty.indexOf(heroIndex);
                
                if (currentSlot !== -1) {
                    // Remove from party
                    this.selectedParty[currentSlot] = null;
                } else {
                    // Add to first empty slot
                    const emptySlot = this.selectedParty.indexOf(null);
                    if (emptySlot !== -1) {
                        this.selectedParty[emptySlot] = heroIndex;
                    }
                }

                this.updatePartySelect();
            }

            previousWave() {
                if (this.currentPreviewWave > 0) {
                    this.currentPreviewWave--;
                    this.updateWaveDisplay();
                }
            }

            nextWave() {
                if (this.currentPreviewWave < this.dungeonWaves.length - 1) {
                    this.currentPreviewWave++;
                    this.updateWaveDisplay();
                }
            }

            startBattleWithParty() {
                const party = this.selectedParty
                    .map(index => index !== null ? this.heroes[index] : null)
                    .filter(hero => hero !== null);

                if (party.length === 0) return;

                this.showBattle();
                this.currentBattle = new Battle(this, party, this.dungeonWaves);
                this.currentBattle.start();
            }

            showBattle() {
                this.hideAllScreens();
                this.currentScreen = 'battleScene';
                document.getElementById('battleScene').style.display = 'block';
                
                // Set battlefield background
                const battleField = document.querySelector('.battleField');
                if (this.currentDungeon) {
                    battleField.style.backgroundImage = `url('https://puzzle-drops.github.io/TEVE/img/fields/${this.currentDungeon.id}.png')`;
                }
            }

            cancelPartySelect() {
                this.showDungeonsScreen();
            }

            exitBattle() {
                if (this.currentBattle) {
                    this.currentBattle.running = false;
                    this.currentBattle = null;
                }
                this.showMainMenu();
            }

            toggleAutoMode(enabled) {
                if (this.currentBattle) {
                    this.currentBattle.toggleAutoMode(enabled);
                }
            }

            showBattleResults() {
                const popup = document.getElementById('battleResultsPopup');
                const results = this.pendingBattleResults;
                
                // Update header
                document.querySelector('.resultsTitle').textContent = results.victory ? 'Victory!' : 'Defeat!';
                document.querySelector('.dungeonInfo').textContent = `${results.dungeonName} - ${results.time}`;
                
                // Update rewards
                document.getElementById('battleTime').textContent = results.time;
                document.getElementById('goldChange').textContent = results.goldChange >= 0 ? `+${results.goldChange}` : results.goldChange;
                
                // Update hero results
                const heroGrid = document.querySelector('.heroResultsGrid');
                heroGrid.innerHTML = '';
                
                results.heroResults.forEach(result => {
                    const heroDiv = document.createElement('div');
                    heroDiv.className = 'heroResult';
                    if (!result.survived) heroDiv.classList.add('dead');
                    
                    heroDiv.innerHTML = `
                        <img src="${result.hero.portraitPath}" alt="${result.hero.name}">
                        <div class="heroResultInfo">
                            <div>${result.hero.name}</div>
                            <div>${result.hero.getDisplayClassName()}</div>
                            <div>${result.survived ? `+${result.expGained} EXP` : 'Did not survive'}</div>
                        </div>
                    `;
                    
                    heroGrid.appendChild(heroDiv);
                });
                
                popup.style.display = 'block';
            }

            closeBattleResults() {
                document.getElementById('battleResultsPopup').style.display = 'none';
                this.applyBattleResults();
                this.showMainMenu();
            }

            applyBattleResults() {
                if (!this.pendingBattleResults) return;
                
                const results = this.pendingBattleResults;
                
                // Apply gold changes
                this.gold += results.goldChange;
                
                // Apply exp to heroes
                results.heroResults.forEach(result => {
                    if (result.survived && result.expGained > 0) {
                        result.hero.addExp(result.expGained);
                    }
                });
                
                this.pendingBattleResults = null;
            }

            closeHeroInfo() {
                document.getElementById('heroInfoPopup').style.display = 'none';
            }

            showAbilityTooltip(event, abilityIndex) {
                const hero = this.heroes[this.selectedHero];
                const ability = hero.abilities[abilityIndex];
                
                const tooltip = document.getElementById('abilityTooltip');
                tooltip.innerHTML = this.formatAbilityTooltip(ability);
                tooltip.style.display = 'block';
                
                // Position tooltip
                const rect = event.target.getBoundingClientRect();
                tooltip.style.left = rect.left + 'px';
                tooltip.style.top = (rect.bottom + 5) + 'px';
            }

            formatAbilityTooltip(ability) {
                const spell = spellManager.getSpell(ability.id);
                if (!spell) return '';
                
                return `
                    <h3>${ability.name} (Level ${ability.level})</h3>
                    <p>${spell.description}</p>
                    ${ability.cooldown > 0 ? `<p>Cooldown: ${ability.cooldown} turns</p>` : ''}
                    ${ability.passive ? '<p class="passiveTag">Passive</p>' : ''}
                `;
            }

            renderStashGrid() {
                const grid = document.querySelector('.stashGrid');
                grid.innerHTML = '<p>Stash system coming soon...</p>';
            }
        }

        // Initialize after loading
        window.addEventListener('load', loadGameData);
    </script>
    <script src="game.js"></script>
    <script src="spellLogic.js"></script>
    <script src="battle.js"></script>
</body>
</html>
